include("../models/dde_model.jl")

using DifferentialEquations
using Integrals

"""
    moo_cost_function(u::Vector{Float64}, local_p::Vector{Any})

Cost function used in multi-objective optimization.

# Arguments
- `u::Vector{Float64}`: Control variable
- `local_p::Vector{Any}`: Parameter values
- `is_circadian::Bool`: Boolean parameter for considering circadian rhythm

# Returns
- `fu::Vector{Float64}`: Objective function values (=[obj1, obj2, ...])
- `gu::Vector{Float64}`: Inequality constraint values
- `hu::Vector{Float64}`: Equality constraint values
"""
function moo_cost_function(u::Vector{Float64}, local_p::Vector{Any}, is_circadian::Bool)
    u1 = vcat(u[1:21], zeros(7))
    u2 = vcat(u[22:end], zeros(7))

    # local_p for thread race
    local_p[end-2] = u1
    local_p[end-1] = u2

    # Setting DDE
    x0, tspan, lags = setup_initial_conditions_time_info(local_p)
    if is_circadian
        prob = DDEProblem(menstrual_cycle_dynamics!, x0, history_func, tspan, local_p; constant_lags=lags)
    else
        prob = DDEProblem(menstrual_cycle_dynamics_no_circ!, x0, history_func, tspan, local_p; constant_lags=lags)
    end

    sol = solve(prob, MethodOfSteps(RK4()), dtmax=0.05)
    if is_circadian
        _, P₄, _ = calculate_auxiliary(sol, local_p, sol.t)
    else
        _, P₄, _ = calculate_auxiliary_no_circ(sol, local_p, sol.t)
    end

    # Main objective function
    obj1 = maximum(P₄) # find a mximum of P₄ among the 3-cycle values

    # Objective dosing amount
    obj2 = sum(u1)+sum(u2)

    fu = [obj1, obj2]

    # Inequality constraints
    gu = [0.0]

    # Equality constraints
    hu = [0.0]

    return fu, gu, hu
end

"""
    f_parallel(X::Matrix{Float64}, p::Vector{Any})

Parallel cost function for multi-objective optimization.
The number of rows of return matrices are the number of threads.

# Arguments
- `X::Matrix{Float64}`: Input values generated by each thread
- `p::Vector{Any}`: Parameter values vector
- `is_circadian:Bool`: Boolean parameter for considering circadian rhythm

# Returns
- `fx::Matrix{Float64}`: Function values matrix for each objective function
- `gx::Matrix{Float64}`: Inequality constraint values (not bounds)
- `hx::Matrix{Float64}`: Equality constraint values
"""
function f_parallel(X::Matrix{Float64}, p::Vector{Any}, is_circadian::Bool)
    N = size(X, 1)
    nobjectives = 2
    fx, gx, hx = zeros(N, nobjectives), zeros(N, 1), zeros(N, 1)
    errors = Threads.Atomic{Int}(0)

    # Use a more fine-grained parallelization with @spawn
    handles = Vector{Task}(undef, N)

    for i in 1:N
        handles[i] = Threads.@spawn begin
            try
                local_p = copy(p)
                fx[i, :], gx[i, :], hx[i, :] = moo_cost_function(X[i, :], local_p, is_circadian)
            catch e
                println("Error occurred at X[$i,:] = ", X[i, 1:10])
                println("Error: ", e)
                fx[i, :], gx[i, :], hx[i, :] = NaN, NaN, NaN 
                Threads.atomic_add!(errors, 1)
            end
        end
    end

    # Wait for all tasks to complete
    for handle in handles
        wait(handle)
    end

    return fx, gx, hx
end

"""
    σ(x::Float64)

The sigmoid function is from NNlib.jl (in efficient way)
"""
function σ(x::Float64)
    t = exp(-abs(x))
    ifelse(x ≥ 0, inv(1 + t), t / (1 + t))
end